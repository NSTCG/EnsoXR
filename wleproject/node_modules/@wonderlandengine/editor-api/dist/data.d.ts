export declare let data: EditorData;
/** Object reference */
export type ObjectReference = string | null;
/** Mesh reference */
export type MeshReference = string | null;
/** Morph targets reference */
export type MorphTargetsReference = string | null;
/** Texture reference */
export type TextureReference = string | null;
/** Shader reference */
export type ShaderReference = string | null;
/** Font reference */
export type FontReference = string | null;
/** Pipeline reference */
export type PipelineReference = string | null;
/** Material reference */
export type MaterialReference = string | null;
/** Skin reference */
export type SkinReference = string | null;
/** Image reference */
export type ImageReference = string | null;
/** Animation reference */
export type AnimationReference = string | null;
/** Particle effect reference */
export type ParticleEffectReference = string | null;
/** Project type */
export declare enum ProjectType {
    Website = "website",
    Game = "game"
}
export declare function toValue(value: any): any;
export declare enum RecordType {
    /** An object record */
    Object = 0,
    /** An array of records */
    Array = 1,
    /** A dictionary (key-value pairs) of records */
    Dict = 2,
    /** A dictionary (key-value pairs) of records with stable indices */
    IdDict = 3
}
export declare class Access {
    recordType?: () => RecordType;
    exists?: (key: string) => boolean;
    keys(): string[];
    values(): any[];
    entries(): [string, any][];
    toValue(): Object;
    toJSON(): Object;
    [Symbol.iterator](): IterableIterator<[string, any]>;
}
/** Project settings */
export declare class ProjectSettings extends Access {
    name: string;
    description: string;
    type: ProjectType;
    customIndexHtml: boolean;
    extraFilesFolder: string;
    prefab: boolean;
    version: number[];
    maxTexturesBinSize: number;
}
/** Workspace settings */
export interface WorkspaceSettings extends Access {
    main: string | null;
    files: string[];
}
/** Sky settings */
export declare class SkySettings extends Access {
    enabled: boolean;
    material: MaterialReference;
}
/** Bloom settings */
export declare class BloomSettings extends Access {
    enabled: boolean;
    passes: number;
    threshold: number;
    intensity: number;
    width: number;
}
/** Tonemapping mode enum */
export declare enum TonemappingMode {
    /** No tonemapping */
    None = "none",
    /** Tonemapping with a polynomial fit of the ACES transform */
    ACES = "aces",
    /** Tonemapping with a simpler fit of the ACES transform */
    ACESApproximated = "aces approximated",
    /** Tonemapping with the Khronos PBR Neutral Tone Mapper */
    KhronosPBRNeutral = "khronos pbr neutral",
    /** Tonemapping with the global Reinhard operator */
    Reinhard = "reinhard",
    /** Tonemapping with an exponential curve */
    Exponential = "exponential"
}
/** HDR settings */
export declare class HdrSettings extends Access {
    exposure: number;
    tonemapping: TonemappingMode;
}
/** Texture streaming settings */
export declare class TextureStreamingSettings extends Access {
    maxCacheSize: number;
    maxUploadPerFrame: number;
}
export declare enum EnvironmentMode {
    Disabled = "disabled",
    SphericalHarmonic0 = "spherical-harmonic-0",
    SphericalHarmonic1 = "spherical-harmonic-1",
    SphericalHarmonic2 = "spherical-harmonic-2"
}
/** Environment settings */
export declare class EnvironmentSettings extends Access {
    enabled: boolean;
    image: ImageReference;
    mode: EnvironmentMode;
    intensity: number;
    bakeExposure: number;
    tint: number[];
    maxSpecularEnvironmentSize: number;
}
/** Rendering settings */
export declare class RenderingSettings extends Access {
    api: 'webgl2' | 'webgpu-or-webgl2';
    textureAtlasSize: number[];
    compressedTextureAtlasSize: number[];
    clearColor: number[];
    maxShadows: number;
    usePreZ: boolean;
    useMultiDraw: boolean;
    useTextureStreaming: boolean;
    sky: SkySettings;
    bloom: BloomSettings;
    hdr: HdrSettings;
    textureStreaming: TextureStreamingSettings;
    environment: EnvironmentSettings;
    maxTextures: number;
}
/** Camera settings */
export declare class CameraSettings extends Access {
    near: number;
    far: number;
}
/** Editor settings */
export declare class EditorSettings extends Access {
    serverPort: number;
    serverCOEP: string;
    camera: CameraSettings;
    ids: string;
    pluginsPaths: string[];
    package: {
        packageUnusedMeshes: boolean;
        packageUnusedAnimations: boolean;
        supercompressionLevel: number;
    };
    importPhysicalAsPhongMaterials: boolean;
}
/** Plugins settings */
export declare class PluginsSettings extends Access {
}
/** PWA settings */
export declare class PWASettings extends Access {
    enable: boolean;
    customServiceWorker: boolean;
    customManifest: boolean;
    display: 'fullscreen' | 'standalone' | 'minimal-ui' | 'browser';
    ovrPackageName: string;
    appIcon: ImageReference;
}
/** Runtime settings */
export declare class RuntimeSettings extends Access {
    visualizeColliders: boolean;
    visualizePhysX: boolean;
    visualizeOverdraw: boolean;
    googleAnalytics: string;
    googleAnalyticsSecondary: string;
    enableRuntimeGltf: boolean;
    viewObject: ObjectReference;
    xrButtonColor: string;
    pwa: PWASettings;
}
/** Bundling type enum */
export declare enum BundlingType {
    None = "none",
    Esbuild = "esbuild",
    Npm = "npm"
}
/** Scripting settings */
export declare class ScriptingSettings extends Access {
    sourcePaths: never[];
    libraryPaths: never[];
    materialDefinitions: string | null;
    components: {
        bundling: string;
        npmScript: string;
        esbuildFlags: string;
        entryPoint: string;
        output: string | null;
    };
    application: {
        bundling: string;
        npmScript: string;
        esbuildFlags: string;
        entryPoint: string;
        output: string | null;
    };
}
/** VR settings */
export declare class VRSettings extends Access {
    enable: boolean;
}
/** AR settings */
export declare class ARSettings extends Access {
    enable: boolean;
}
/** WebXR feature flags */
export interface WebXRFeatureFlags {
    'local': boolean;
    'local-floor': boolean;
    'bounded-floor': boolean;
    'unbounded': boolean;
    'hand-tracking': boolean;
    'hit-test': boolean;
    'plane-detection': boolean;
    'light-estimation': boolean;
    'anchors': boolean;
    'occlusion': boolean;
    'marker-tracking': boolean;
}
/** WebXR settings */
export declare class WebXRSettings extends Access {
    framebufferScaleFactor: number;
    offerSession: boolean;
    optionalFeatures: WebXRFeatureFlags;
    optionalFeaturesExtra: string;
    requiredFeatures: WebXRFeatureFlags;
    requiredFeaturesExtra: string;
}
/** XR settings */
export declare class XRSettings extends Access {
    vr: VRSettings;
    ar: ARSettings;
    webxr: WebXRSettings;
    leftEyeObject: ObjectReference;
    rightEyeObject: ObjectReference;
}
/** Physics settings */
export declare class PhysXSettings extends Access {
    enable: boolean;
    maxTimestep: number;
    contactOffset: number;
    restOffset: number;
    groupNames: {
        '0': string;
        '1': string;
        '2': string;
        '3': string;
        '4': string;
        '5': string;
        '6': string;
        '7': string;
    };
    gravity: number[];
    lengthToleranceScale: number;
    speedToleranceScale: number;
}
/** Localization settings */
export declare class LocalizationSettings extends Access {
    enableZipCompression: boolean;
    format: 'i18next';
    languagesFolder: string;
    defaultLanguage: string;
}
/** Settings for the currently open project */
export interface Settings extends Access {
    project: ProjectSettings;
    workspace: WorkspaceSettings;
    rendering: RenderingSettings;
    editor: EditorSettings;
    runtime: RuntimeSettings;
    scripting: ScriptingSettings;
    plugins: PluginsSettings;
    xr: XRSettings;
    physx: PhysXSettings;
    localization: LocalizationSettings;
}
/** Image compression type */
export declare enum ImageCompressionType {
    None = "etc1s",
    ETC1s = "etc1s",
    UASTC = "uastc"
}
export declare class Link extends Access {
    name: string;
    file: string;
}
export declare class Resource extends Access {
    name: string;
    link: Link | null;
    packageAlways: boolean;
}
/** Image resource */
export declare class ImageResource extends Resource {
    name: string;
    maxSize: number[];
    compression: ImageCompressionType;
    stream: boolean;
    hdr: boolean;
}
/** Texture resource */
export declare class TextureResource extends Resource {
    name: string;
    image: ImageReference;
    type: number;
    minFilter: number;
    magFilter: number;
    mipFilter: number;
    wrapping: number[];
}
/** Shader stage enum */
export declare enum ShaderStage {
    Fragment = "fragment",
    Vertex = "vertex"
}
/** Shader type enum */
export declare enum ShaderType {
    Forward = "forward",
    Fullscreen = "fullscreen"
}
/** Shader resource */
export declare class ShaderResource extends Resource {
    name: string;
    stage: ShaderStage;
    type: ShaderType;
    packageUnused: boolean;
}
/** Mesh resource */
export declare class MeshResource extends Resource {
    name: string;
    simplify: boolean;
    simplifyTarget: number;
    simplifyTargetError: number;
    importScaling: number;
    hasMorphTargets: boolean;
}
/** Material properties for the default Phong pipeline */
export declare class PhongMaterial extends Access {
    ambientColor: number[];
    diffuseTexture: TextureReference;
    diffuseColor: number[];
    specularColor: number[];
    emissiveTexture: TextureReference;
    emissiveColor: number[];
    fogColor: number[];
    normalTexture: TextureReference;
    lightmapTexture: TextureReference;
    lightmapFactor: number;
    shininess: number;
    alphaMaskThreshold: number;
    alphaMaskTexture: TextureReference;
}
/** Material properties for the default Phong pipeline */
export declare class PhysicalMaterial extends Access {
    albedoColor: number[];
    emissiveTexture: TextureReference;
    emissiveColor: number[];
    fogColor: number[];
    albedoTexture: TextureReference;
    metallicFactor: number;
    roughnessFactor: number;
    occlusionRoughnessMetallicTexture: TextureReference;
    roughnessMetallicTexture: TextureReference;
    specularProbeTexture: TextureReference;
    irradianceProbeTexture: TextureReference;
    normalTexture: TextureReference;
    occlusionTexture: TextureReference;
    occlusionFactor: number;
    alphaMaskThreshold: number;
    alphaMaskTexture: TextureReference;
}
/** Material properties for the default MeshVisualizer pipeline */
export declare class MeshVisualizerMaterial extends Access {
    color: number[];
    wireframeColor: number[];
}
/** Material properties for the default Flat pipeline */
export declare class FlatMaterial extends Access {
    color: number[];
    flatTexture: TextureReference;
    alphaMaskThreshold: number;
    alphaMaskTexture: TextureReference;
}
/** Material properties for the default Particle pipeline */
export declare class ParticleMaterial extends Access {
    color: number[];
    mainTexture: TextureReference;
    noiseTexture: TextureReference;
    offsetX: number;
    offsetY: number;
}
/** Material properties for the default DistanceFieldVector pipeline */
export declare class DistanceFieldVectorMaterial extends Access {
    color: number[];
    outlineColor: number[];
    outlineRange: number[];
    vectorTexture: TextureReference;
    smoothness: number;
}
/** Material properties for the default Text pipeline */
export declare class TextMaterial extends Access {
    color: number[];
    effectColor: number[];
    font: FontReference;
}
/** Material properties for the default Sky pipeline */
export declare class SkyMaterial extends Access {
    colorStop0: number[];
    colorStop1: number[];
    colorStop2: number[];
    colorStop3: number[];
    texture: TextureReference;
}
/** Material properties for the default Sky pipeline */
export declare class AtmosphericSkyMaterial extends Access {
    direction: number[];
    exposure: number;
}
/** Material properties for the default Background pipeline */
export declare class BackgroundMaterial extends Access {
    colorStop0: number[];
    colorStop1: number[];
    colorStop2: number[];
    colorStop3: number[];
    texture: TextureReference;
}
/** Material properties for the default Particle pipeline */
export declare class MaterialResource extends Resource {
    pipeline: PipelineReference;
    name: string;
    Phong?: PhongMaterial;
    Physical?: PhysicalMaterial;
    MeshVisualizer?: MeshVisualizerMaterial;
    Flat?: FlatMaterial;
    Particle?: ParticleMaterial;
    DistanceFieldVector?: DistanceFieldVectorMaterial;
    Text?: TextMaterial;
    Sky?: SkyMaterial;
    AtmosphericSky?: AtmosphericSkyMaterial;
    Background?: BackgroundMaterial;
}
/** Animation blending type */
export declare enum AnimationBlendType {
    None = "none",
    Blend1D = "blend1D"
}
/** Root motion handling mode */
export declare enum RootMotionMode {
    None = "none",
    ApplyToOwner = "applyToOwner",
    ScriptEvent = "scriptEvent"
}
/** 'animation' component */
export declare class AnimationComponent extends Access {
    preview: boolean;
    retarget: boolean;
    autoplay: boolean;
    playCount: number;
    speed: number;
    skin: SkinReference;
    animation: AnimationReference;
    rootMotionMode: RootMotionMode;
    blendFactor: number;
    blendType: AnimationBlendType;
    blendAnimations: {
        animations: AnimationReference[];
        playbackSpeeds: number[];
    };
}
/** Light type enum */
export declare enum LightType {
    /** Point light type */
    Point = "point",
    /** Spot light type */
    Spot = "spot",
    /** Sun light type */
    Sun = "sun"
}
/** 'light' component */
export declare class LightComponent extends Access {
    type: LightType;
    color: number[];
    intensity: number;
    shadowRange: number;
    outerAngle: number;
    innerAngle: number;
    shadows: boolean;
    shadowBias: number;
    shadowNormalBias: number;
    shadowTexelSize: number;
    cascadeCount: number;
}
/** View projection type enum */
export declare enum ProjectionType {
    /** Perspective projection */
    Perspective = "perspective",
    /** Orthographic projection */
    Orthographic = "orthographic"
}
/** 'view' component */
export declare class ViewComponent extends Access {
    projectionType: ProjectionType;
    fov: number;
    extent: number;
    near: number;
    far: number;
}
/** Sphere physics shape */
export declare class PhysXSphere extends Access {
    radius: number;
}
/** Box physics shape */
export declare class PhysXBox extends Access {
    extents: number[];
}
/** Capsule physics shape */
export declare class PhysXCapsule extends Access {
    radius: number;
    halfHeight: number;
}
/** Triangle mesh physics shape */
export declare class PhysXTriangleMesh extends Access {
    mesh: MeshReference;
    scaling: number[];
}
/** Convex mesh physics shape */
export declare class PhysXConvexMesh extends Access {
    mesh: MeshReference;
    scaling: number[];
}
/** Physics shape type enum */
export declare enum PhysXShapeType {
    Sphere = "sphere",
    Box = "box",
    Capsule = "capsule",
    TriangleMesh = "triangleMesh",
    ConvexMesh = "convexMesh"
}
/** 'physx' component */
export declare class PhysXComponent extends Access {
    static: boolean;
    kinematic: boolean;
    simulate: boolean;
    allowQuery: boolean;
    allowSimulation: boolean;
    mass: number;
    shape: PhysXShapeType;
    sphere?: PhysXSphere;
    box?: PhysXBox;
    capsule?: PhysXCapsule;
    triangleMesh?: PhysXTriangleMesh;
    convexMesh?: PhysXConvexMesh;
    linearDamping: number;
    angularDamping: number;
    staticFriction: number;
    dynamicFriction: number;
    bounciness: number;
    gravity: boolean;
    trigger: boolean;
    block: number;
    groups: number;
    lockAxis: number;
    sleepOnActivate: boolean;
    translationOffset: number[];
    rotationOffset: number[];
    solverPositionIterations: number;
    solverVelocityIterations: number;
}
/** 'mesh' component */
export declare class MeshComponent extends Access {
    material: MaterialReference;
    mesh: MeshReference;
    skin: SkinReference;
    morphTargets: MorphTargetsReference;
    morphTargetWeights: number[];
}
/** Text effect type enum */
export declare enum TextEffectType {
    None = "none",
    Outline = "outline",
    Shadow = "shadow"
}
/** Text wrap mode */
export declare enum TextWrapMode {
    None = "none",
    Soft = "soft",
    Hard = "hard",
    Clip = "clip"
}
/** 'text' component */
export declare class TextComponent extends Access {
    alignment: string;
    verticalAlignment: string;
    justified: boolean;
    characterSpacing: number;
    lineSpacing: number;
    effect: TextEffectType;
    effectOffset: number[];
    text: string;
    material: MaterialReference;
    wrapMode: TextWrapMode;
    wrapWidth: number;
}
/** Sphere collider */
export declare class Sphere extends Access {
    radius: number;
}
/** AxisAlignedBoundingBox collider */
export declare class AABB extends Access {
    extents: number[];
}
/** Box collider */
export declare class Box extends Access {
    extents: number[];
}
/** 'collision' component */
export declare class CollisionComponent extends Access {
    collider: 'sphere' | 'aabb' | 'box';
    sphere?: Sphere;
    aabb?: AABB;
    box?: Box;
    groups: number;
}
/** Input type enum */
export declare enum InputType {
    Head = "head",
    EyeLeft = "eye left",
    EyeRight = "eye right",
    HandLeft = "hand left",
    HandRight = "hand right",
    RayLeft = "ray left",
    RayRight = "ray right"
}
/** 'input' component */
export declare class InputComponent extends Access {
    type: InputType;
}
/** 'particle-effect' component */
export declare class ParticleEffectComponent extends Access {
    particleEffect: ParticleEffectReference;
}
export declare class AnimationEvent extends Access {
    time: number;
    name: string;
}
export declare class RootMotion extends Access {
    target: ObjectReference;
    translationAxis: number;
    rotationAxis: number;
}
/** Animation resource */
export declare class AnimationResource extends Resource {
    /** Name of the animation */
    name: string;
    /** Whether to compress the animation */
    pack: boolean;
    /** Targets influenced per track */
    targets: ObjectReference[];
    /** Animation events track */
    events: AnimationEvent[];
    rootMotion?: RootMotion;
}
/** Component */
export declare class ObjectComponent extends Access {
    /** Component type */
    type: string | null;
    /** Whether the component is active */
    active: boolean;
    /** Animation component */
    animation?: AnimationComponent;
    /** Collision component */
    collision?: CollisionComponent;
    /** Input component */
    input?: InputComponent;
    /** Light component */
    light?: LightComponent;
    /** Mesh component */
    mesh?: MeshComponent;
    /** Physx component */
    physx?: PhysXComponent;
    /** Text component */
    text?: TextComponent;
    /** View component */
    view?: ViewComponent;
    /** Particle effect component */
    particleEffect?: ParticleEffectComponent;
}
/** Object resource */
export declare class ObjectResource extends Resource {
    /** Name of the object */
    name: string;
    /** Translation vector */
    translation: number[];
    /** Rotation quaternion */
    rotation: number[];
    /** Scaling vector */
    scaling: number[];
    /** Parent object, or null if parent is root */
    parent: ObjectReference;
    /** Skin this object is part of, or `null`, if not a joint. */
    skin: SkinReference;
    /** List of components on this object */
    components: ObjectComponent[];
}
/** Skin resource */
export declare class SkinResource extends Resource {
    /** Name of the skin */
    name: string;
    /** List of objects that make up the joints of this skin */
    joints: ObjectReference[];
}
/** Blend function enum for {@link PipelineResource} */
export declare enum BlendFunction {
    Zero = "zero",
    One = "one",
    SourceColor = "source color",
    OnceMinusSourceColor = "one minus source color",
    SourceAlpha = "source alpha",
    SourceAlphaSaturate = "source alpha saturate",
    OneMinusSourceAlpha = "one minus source alpha",
    DestinationColor = "destination color",
    OneMinusDestinationColor = "one minus destination color",
    DestinationAlpha = "destination alpha",
    OneMinusDestinationAlpha = "one minus destination alpha"
}
/** Blend equation enum for {@link PipelineResource} */
export declare enum BlendEquation {
    Add = "add",
    Subtract = "subtract",
    ReverseSubtract = "reverse subtract",
    Min = "min",
    Max = "max"
}
/** Depth function enum for {@link PipelineResource} */
export declare enum DepthFunction {
    Never = "never",
    Always = "always",
    Less = "less",
    LessOrEqual = "less or equal",
    Equal = "equal",
    NotEqual = "not equal",
    GreaterOrEqual = "greater or equal",
    Greater = "greater"
}
/** Mesh sorting mode */
export declare enum MeshSorting {
    None = "none",
    Z = "z",
    InverseZ = "inverse-z",
    MeshIndex = "mesh-index"
}
/** Pipeline resource */
export declare class PipelineResource extends Resource {
    name: string;
    doubleSided: boolean;
    castShadows: boolean;
    colorWrite: {
        red: boolean;
        green: boolean;
        blue: boolean;
        alpha: boolean;
    };
    depthTest: boolean;
    depthWrite: boolean;
    blending: boolean;
    sampleAlphaToCoverage: boolean;
    shader: ShaderReference;
    viewVertexShader: ShaderReference;
    features: {
        [key: string]: boolean;
    };
    meshSorting: MeshSorting;
    blendSrcRgb: BlendFunction;
    blendSrcAlpha: BlendFunction;
    blendDestRgb: BlendFunction;
    blendDestAlpha: BlendFunction;
    blendEqRgb: BlendEquation;
    blendEqAlpha: BlendEquation;
    depthFunction: DepthFunction;
}
/** Font resource */
export declare class FontResource extends Resource {
    /** Name of the font */
    name: string;
    /** Which characters need to be renderable with this font */
    characters: string;
    /** Whether to support the "outline" effect with this font */
    outline: boolean;
    /** Size of the outline */
    outlineSize: number;
}
/** Language resource */
export declare class LanguageResource extends Resource {
    /** Name of the language */
    name: string;
    /** Whether this is the default language */
    isDefault: boolean;
}
/** Particle effect resource */
export declare class ParticleEffectResource extends Resource {
    name: string;
}
/** File resource */
export declare class FileResource extends Resource {
    fileName: string;
    importerName: string;
    importPhysicalAsPhongMaterials: boolean;
}
export declare class ResourceSection<T> {
    [key: string]: T;
}
/**
 * Access to Wonderland Editor's data.
 *
 * Hold control and hover any field in Wonderland Editor to see its JSON path.
 * The path is equivalent to how you find the matching chain of properties.
 * @example
 *
 * ```
 *    /objects/123/components/0/text/text
 * ```
 *
 * Will match the following code:
 *
 * ```ts
 *    WL.data.objects[123].components[0].text.text
 * ```
 */
export interface EditorData {
    /** Project settings */
    settings: Settings;
    /** List of scene file paths */
    files: ResourceSection<FileResource>;
    /** Animation resources */
    animations: ResourceSection<AnimationResource>;
    /** Object resources */
    objects: ResourceSection<ObjectResource>;
    /** Skin resources */
    skins: ResourceSection<SkinResource>;
    /** Image resources */
    images: ResourceSection<ImageResource>;
    /** Shader resources */
    shaders: ResourceSection<ShaderResource>;
    /** Mesh resources */
    meshes: ResourceSection<MeshResource>;
    /** Texture resources */
    textures: ResourceSection<TextureResource>;
    /** Material resources */
    materials: ResourceSection<MaterialResource>;
    /** Font resources */
    fonts: ResourceSection<FontResource>;
    /** Pipeline resources */
    pipelines: ResourceSection<PipelineResource>;
    /** Language resources */
    languages: ResourceSection<LanguageResource>;
    /** Particle effect resources */
    particleEffects: ResourceSection<ParticleEffectResource>;
}
